{"pages":[{"title":"","text":"64fc6d6fc4408b48b38dc3f189de2a61","link":"/baidu_verify_code-c90Iop9840.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo d More info: Deployment","link":"/20210916/hello-world/"},{"title":"团队中应当如何提升代码质量","text":"代码质量其实是老生常谈的一个词，同时 质量 也是一个很主观的词，代码质量的好与坏究竟该如何评判，是否有一个定性和定量的标准，有了这个标准之后，在团队中间又将如何推动落地，希望这篇博文能够为你带来一点思路。 为什么要谈代码质量很大一部分开发同学有一个认知，觉得代码 “能跑就行了”，写完自己多看一眼就会看不懂的代码之后，大手一挥完全不顾后来人的死活。相信很多开发同学都碰到过这样的代码： 一个几百上千行的函数中间充斥着多年前留下来的古老注释与不明所以的分支逻辑，没有人敢删，也没有人敢改，所有业务知识全靠口口相传，新的需求如果要动到这段上古代码，就只能开始祈祷式编程，结果往往也是代码一动 bug 就来了。 如果你有共鸣，那我相信你内心其实是知道提高代码质量的必要性的，在我看来，提升代码质量的意义在于： 降低新人的学习成本 降低代码的后期维护成本 降低莫名其妙的 bug 出现率 增强编码人员对代码的信心 如何落地在团队中的落地实践是我想重点谈一谈的，落地的过程中少不了硬性规定的实施与相关技能的培训，所以前期需要投入一定精力去建设质量保障体系，具体如下： 制定规范与标准规范与标准的制定对于每个团队而言都大同小异，没有标准答案，关键是一定要在团队内部达成共识，在这里强烈建议参考《代码整洁之道》一书中的一到四章，熟读之后能够对规范的制定有一个更加具体的思路。这里我举几条之前公司的规范以供参考： 使用了 TypeScript 的项目，函数必须显式标明参数类型与返回值类型，void 除外 变量必须以驼峰形式英文命名，且不得有缩写的单词，行业或业务专有名词除外 变量命名需有明确的业务含义，不得以 info/data/list 这种毫无意义的单词进行命名 补充必要的单元测试这里提到的单元测试（unit test）是指由开发人员在代码中去编写的测试，前端单元测试框架推荐 Jest，单元测试可以让你在阅读以前的代码时，多一个途径去了解相关的业务逻辑，同时也能够增强改动这段代码的信心。如果你对单元测试没有概念，可以参考以下这个示例： 123456789101112131415161718192021// 以下是业务逻辑onComponentInit() { if (this.isCreate) { this.tip = 'create mode'; this.tipService.updateTip(this.tip); }}// 以下是对应的单元测试test('should get expected tip and call update tip method when component init giving isCreate is true', () =&gt; { // given component.isCreate = true; const methodSpy = jest.spyOn(TestBed.inject(TipService), 'updateTip'); // when component.onComponentInit(); // then expect(component.tip).toEqual('create mode'); expect(methodSpy).toHaveBeenCalledWith('create mode');}); 好的代码应当是自描述的，好的单元测试也是。以上这个单元测试做了两件事： 告诉阅读这段业务逻辑的人，这个分支下会做两件事情：给一个变量赋值、调用一个方法 保护这段业务逻辑不受重构的伤害，当你删除任何一行业务逻辑中的代码，这个单元测试就会运行失败 质量检查流程化自动化当开发同学写完代码之后，我们又该如何去判断代码质量的高低呢？首先还是建议引入一些自动化工具来做这件事情，质量检查应当是一个持续的、轻量的过程，不应当也不可能花费太多人力成本在这件事上。检查的流程建议至少包含这三个阶段： 单元测试覆盖率检查 lint 格式检查 sonar 静态代码扫描 对于有 CI （如 Jenkins）相关基础设施的团队，可以充分利用持续集成的优势，为项目配置一条包含以上三个步骤的流水线，保证每次 push 代码之后都能够触发代码质量的自动检查。如果没有 CI 相关设施，可以利用 Git Hooks 在 push 的时候在本地进行质量的检查。有了定性的检查措施之后，流水线运行失败就意味着代码质量没有达到约定的标准，进而督促相关的开发同学对自己的代码进行改进。 定期代码检视（code review）代码检视很有必要，但是很多开发同学都比较抵触，所以推动起来也不是一件容易的事，建议先降低频率，小范围试点推行。代码检视的形式个人更倾向于由 tech leader 主讲的集体检视，相较于一对一检视的优势有以下几点： 检视过程是业务传递的过程，可以让大家都了解小组内彼此的业务 当发现问题时，纠正的过程就是一次集体的知识传递，能够让成员都了解这个规则 代码检视的最终目的就是提高大家的代码质量，和上图一样，从 Bad code 到 Good code 的过程其实就是代码检视时 WTF 数量逐渐收敛的过程，当大家的代码质量逐渐提高，代码检视时遇到的问题也会逐渐减少。 写在最后代码质量的提升必然是一个长期的过程，在这个过程中也许看不到即时收益，但是对于开发团队长期的发展而言是必不可少的，如果始终不去关注项目的代码质量，势必会导致技术债积压越来越多，到最后实在无法维护了，甚至需要重新立项进行整体的重构，到时就得不偿失了。","link":"/20210921/%E5%9B%A2%E9%98%9F%E4%B8%AD%E5%BA%94%E5%BD%93%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"},{"title":"利用 GitLab CI&#x2F;CD 搭建质量检查流水线","text":"前面的文章有介绍团队如何去提高代码质量，其中比较重要的一个环节就是实现质量检查的流程化与自动化。这里的质量检查可以通过 ESLint 和 Sonar 的代码质量扫描实现，流程化自动化则采用 CI/CD 框架如 Jenkins、GitLab 来实现。 框架介绍GitLabGitLab 其实大家很熟悉，就是类似于 Github、码云之类的代码托管平台。这里想介绍的是 GitLab 的持续集成持续交付能力即 CI/CD，相较于 Jenkins， GitLab CI/CD 配置较为简单、与代码仓库结合紧密且可视化程度高。 SonarSonar 是一个静态代码扫描工具，它不仅可以像 ESLint 一样进行代码的质量检查，还可以从安全性、可维护性、测试覆盖率、代码复杂度、代码重复度等多个维度提供图表化的直观度量，每一次的扫描结果也会记录到服务端，以提供项目开发过程中的代码质量变化趋势。 搭建质量检查流水线流水线就是质量检查自动化的载体，它包含 ESLint 和 Sonar 两个步骤，每次提交代码将会自动触发流水线的运行，每次流水线运行也将触发 ESLint 和 Sonar 的执行。 GitLab CI/CD 的配置只需要在代码根目录下添加一个 yaml 文件 .gitlab-ci.yml，在这个配置文件中增加 ESLint 和 Sonar 的步骤即可，示例代码如下： 12345678910111213141516stages: - lint - sonar lint: stage: lint image: node:latest script: - npm install - npm run lint sonar: stage: sonar image: sonar-scanner:latest script: - sonar-scanner -Dsonar.projectKey=project-name -Dsonar.sources=./src -Dsonar.host.url=https://sonar.server.com -Dsonar.login=your-token 介绍一下其中部分参数： stages：即流水线的步骤，这里一共定义了两个步骤：lint 和 sonar，注意 stages 是串行的，默认情况下只有前一个步骤运行成功了，才能触发后面步骤的运行； image：即步骤执行脚本时所用到的镜像，在 lint 这一步骤中用到的镜像是 node 的最新版本，因为脚本中有 npm，所以必须拉取node 镜像才能执行，sonar 步骤中的镜像则拉取了 sonar-scanner 的最新版本； script：这个比较容易理解，即每个步骤运行时对应要执行的脚本。 其中 sonar 这一步骤的脚本定义了四个参数，意义如下： 参数 含义 是否必须 sonar.projectKey sonar 服务端中对应的 project key，需要先在 sonar 中新建对应的项目 是 sonar.sources sonar 扫描的代码目录，为相对根目录的路径 否 sonar.host.url sonar 服务端地址 是 sonar.login sonar 服务端生成的 token，鉴权使用 否 验证GitLab 流水线默认情况下 push 了代码就会触发运行，提交代码后进入 GitLab –&gt; CI/CD –&gt; Pipelines 查看是否运行成功，每个 stage 可以点击进去查看相关日志，sonar 运行完成后，进入 sonar 服务端查看对应的扫描结果。","link":"/20211107/%E5%88%A9%E7%94%A8-Gitlab-CI-CD-%E6%90%AD%E5%BB%BA%E8%B4%A8%E9%87%8F%E6%A3%80%E6%9F%A5%E6%B5%81%E6%B0%B4%E7%BA%BF/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"代码质量","slug":"代码质量","link":"/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"},{"name":"CI&#x2F;CD","slug":"CI-CD","link":"/tags/CI-CD/"},{"name":"流水线","slug":"流水线","link":"/tags/%E6%B5%81%E6%B0%B4%E7%BA%BF/"}],"categories":[{"name":"个站","slug":"个站","link":"/categories/%E4%B8%AA%E7%AB%99/"},{"name":"工程实践","slug":"工程实践","link":"/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"}]}