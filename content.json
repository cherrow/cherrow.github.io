{"pages":[{"title":"","text":"64fc6d6fc4408b48b38dc3f189de2a61","link":"/baidu_verify_code-c90Iop9840.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo d More info: Deployment","link":"/20210916/hello-world/"},{"title":"兼容性问题不完全记录","text":"前端开发的朋友肯定遇到过不少兼容性问题，包括不同浏览器、不同设备、同一浏览器不同版本等等，这篇文章就用来记录我在日常开发中遇到过的一些兼容性问题，吃一堑长一智，同样的问题下次再遇到就能混个脸熟了。 样式大部分情况其实都是样式兼容性问题，如果有不确定的样式，建议先去 caniuse 搜索一下，这个网站会详细列出你搜索样式的所有兼容情况。 flex 布局现象： 使用 align-items: end 实现子元素底部对齐，Chrome 浏览器生效，Safari 不生效。 排查： 在 caniuse 网站中搜索该样式，发现 align-items 属性不仅用于 flex 布局，还可用于 grid 布局，而属性值 start 和 end 在 flex 布局中是不兼容 Safari 浏览器的，必须使用 flex-start 和 flex-end。 解决： 改为 align-items: flex-end 即可。 js大家都知道 JavaScript 其实是由三部分组成： ECMAScript：由 ECMA-262 定义并提供核心功能； 文档对象模型(DOM)：提供与网页内容交互的方法和接口； 浏览器对象模型(BOM)：提供与浏览器交互的方法和接口。 ECMAScript 作为核心 API 本身是不存在兼容性问题的，只是它与 BOM 和 DOM 一样，不同浏览器对 API 的实现与支持有可能不同，因此就会导致兼容性问题的出现。 Date 格式化现象： 在对日期进行格式化时，发现 Chrome 和 Safari 的表现不一样： 1234var date = new Date('2021-10-25 12:50');console.log(date)// Chrome ---&gt; Mon Oct 25 2021 12:50:00 GMT+0800 (中国标准时间)// Safari ---&gt; Invalid Date 排查： 查阅 MDN 发现，在部分浏览器中所要解析的日期必须符合 ISO 8601 日期格式，显然 Safari 就是其中之一。在 Safari 中验证结果如下： 1234567console.log(new Date('2021-10-25')) // Mon Oct 25 2021 08:00:00 GMT+0800 (CST)console.log(new Date('2021/10/25')) // Mon Oct 25 2021 00:00:00 GMT+0800 (CST)console.log(new Date('2021-10-25T12:50')) // Mon Oct 25 2021 12:50:00 GMT+0800 (CST)console.log(new Date('2021-10-25T12:50Z')) // Mon Oct 25 2021 20:50:00 GMT+0800 (CST)console.log(new Date('2021/10/25T12:50')) // Invalid Dateconsole.log(new Date('2021/10/25T12:50Z')) // Invalid Dateconsole.log(new Date('2021/10/25 12:50')) // Mon Oct 25 2021 12:50:00 GMT+0800 (CST) 解决： 采用了替换横杠为斜杠的方式： 1234var date = new Date('2021-10-25 12:50'.replace(/-/g, '/'))console.log(date)// Chrome ---&gt; Mon Oct 25 2021 12:50:00 GMT+0800 (中国标准时间)// Safari ---&gt; Mon Oct 25 2021 12:50:00 GMT+0800 (CST)","link":"/20211208/%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AE%B0%E5%BD%95/"},{"title":"利用 GitLab CI&#x2F;CD 搭建质量检查流水线","text":"前面的文章有介绍团队如何去提高代码质量，其中比较重要的一个环节就是实现质量检查的流程化与自动化。这里的质量检查可以通过 ESLint 和 Sonar 的代码质量扫描实现，流程化自动化则采用 CI/CD 框架如 Jenkins、GitLab 来实现。 框架介绍GitLabGitLab 其实大家很熟悉，就是类似于 Github、码云之类的代码托管平台。这里想介绍的是 GitLab 的持续集成持续交付能力即 CI/CD，相较于 Jenkins， GitLab CI/CD 配置较为简单、与代码仓库结合紧密且可视化程度高。 SonarSonar 是一个静态代码扫描工具，它不仅可以像 ESLint 一样进行代码的质量检查，还可以从安全性、可维护性、测试覆盖率、代码复杂度、代码重复度等多个维度提供图表化的直观度量，每一次的扫描结果也会记录到服务端，以提供项目开发过程中的代码质量变化趋势。 搭建质量检查流水线流水线就是质量检查自动化的载体，它包含 ESLint 和 Sonar 两个步骤，每次提交代码将会自动触发流水线的运行，每次流水线运行也将触发 ESLint 和 Sonar 的执行。 GitLab CI/CD 的配置只需要在代码根目录下添加一个 yaml 文件 .gitlab-ci.yml，在这个配置文件中增加 ESLint 和 Sonar 的步骤即可，示例代码如下： 12345678910111213141516stages: - lint - sonar lint: stage: lint image: node:latest script: - npm install - npm run lint sonar: stage: sonar image: sonar-scanner:latest script: - sonar-scanner -Dsonar.projectKey=project-name -Dsonar.sources=./src -Dsonar.host.url=https://sonar.server.com -Dsonar.login=your-token 介绍一下其中部分参数： stages：即流水线的步骤，这里一共定义了两个步骤：lint 和 sonar，注意 stages 是串行的，默认情况下只有前一个步骤运行成功了，才能触发后面步骤的运行； image：即步骤执行脚本时所用到的镜像，在 lint 这一步骤中用到的镜像是 node 的最新版本，因为脚本中有 npm，所以必须拉取node 镜像才能执行，sonar 步骤中的镜像则拉取了 sonar-scanner 的最新版本； script：这个比较容易理解，即每个步骤运行时对应要执行的脚本。 其中 sonar 这一步骤的脚本定义了四个参数，意义如下： 参数 含义 是否必须 sonar.projectKey sonar 服务端中对应的 project key，需要先在 sonar 中新建对应的项目 是 sonar.sources sonar 扫描的代码目录，为相对根目录的路径 否 sonar.host.url sonar 服务端地址 是 sonar.login sonar 服务端生成的 token，鉴权使用 否 验证GitLab 流水线默认情况下 push 了代码就会触发运行，提交代码后进入 GitLab –&gt; CI/CD –&gt; Pipelines 查看是否运行成功，每个 stage 可以点击进去查看相关日志，sonar 运行完成后，进入 sonar 服务端查看对应的扫描结果。","link":"/20211107/%E5%88%A9%E7%94%A8-Gitlab-CI-CD-%E6%90%AD%E5%BB%BA%E8%B4%A8%E9%87%8F%E6%A3%80%E6%9F%A5%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"title":"团队中应当如何提升代码质量","text":"代码质量其实是老生常谈的一个词，同时 质量 也是一个很主观的词，代码质量的好与坏究竟该如何评判，是否有一个定性和定量的标准，有了这个标准之后，在团队中间又将如何推动落地，希望这篇博文能够为你带来一点思路。 为什么要谈代码质量很大一部分开发同学有一个认知，觉得代码 “能跑就行了”，写完自己多看一眼就会看不懂的代码之后，大手一挥完全不顾后来人的死活。相信很多开发同学都碰到过这样的代码： 一个几百上千行的函数中间充斥着多年前留下来的古老注释与不明所以的分支逻辑，没有人敢删，也没有人敢改，所有业务知识全靠口口相传，新的需求如果要动到这段上古代码，就只能开始祈祷式编程，结果往往也是代码一动 bug 就来了。 如果你有共鸣，那我相信你内心其实是知道提高代码质量的必要性的，在我看来，提升代码质量的意义在于： 降低新人的学习成本 降低代码的后期维护成本 降低莫名其妙的 bug 出现率 增强编码人员对代码的信心 如何落地在团队中的落地实践是我想重点谈一谈的，落地的过程中少不了硬性规定的实施与相关技能的培训，所以前期需要投入一定精力去建设质量保障体系，具体如下： 制定规范与标准规范与标准的制定对于每个团队而言都大同小异，没有标准答案，关键是一定要在团队内部达成共识，在这里强烈建议参考《代码整洁之道》一书中的一到四章，熟读之后能够对规范的制定有一个更加具体的思路。这里我举几条之前公司的规范以供参考： 使用了 TypeScript 的项目，函数必须显式标明参数类型与返回值类型，void 除外 变量必须以驼峰形式英文命名，且不得有缩写的单词，行业或业务专有名词除外 变量命名需有明确的业务含义，不得以 info/data/list 这种毫无意义的单词进行命名 补充必要的单元测试这里提到的单元测试（unit test）是指由开发人员在代码中去编写的测试，前端单元测试框架推荐 Jest，单元测试可以让你在阅读以前的代码时，多一个途径去了解相关的业务逻辑，同时也能够增强改动这段代码的信心。如果你对单元测试没有概念，可以参考以下这个示例： 123456789101112131415161718192021// 以下是业务逻辑onComponentInit() { if (this.isCreate) { this.tip = 'create mode'; this.tipService.updateTip(this.tip); }}// 以下是对应的单元测试test('should get expected tip and call update tip method when component init giving isCreate is true', () =&gt; { // given component.isCreate = true; const methodSpy = jest.spyOn(TestBed.inject(TipService), 'updateTip'); // when component.onComponentInit(); // then expect(component.tip).toEqual('create mode'); expect(methodSpy).toHaveBeenCalledWith('create mode');}); 好的代码应当是自描述的，好的单元测试也是。以上这个单元测试做了两件事： 告诉阅读这段业务逻辑的人，这个分支下会做两件事情：给一个变量赋值、调用一个方法 保护这段业务逻辑不受重构的伤害，当你删除任何一行业务逻辑中的代码，这个单元测试就会运行失败 质量检查流程化自动化当开发同学写完代码之后，我们又该如何去判断代码质量的高低呢？首先还是建议引入一些自动化工具来做这件事情，质量检查应当是一个持续的、轻量的过程，不应当也不可能花费太多人力成本在这件事上。检查的流程建议至少包含这三个阶段： 单元测试覆盖率检查 lint 格式检查 sonar 静态代码扫描 对于有 CI （如 Jenkins）相关基础设施的团队，可以充分利用持续集成的优势，为项目配置一条包含以上三个步骤的流水线，保证每次 push 代码之后都能够触发代码质量的自动检查。如果没有 CI 相关设施，可以利用 Git Hooks 在 push 的时候在本地进行质量的检查。有了定性的检查措施之后，流水线运行失败就意味着代码质量没有达到约定的标准，进而督促相关的开发同学对自己的代码进行改进。 定期代码检视（code review）代码检视很有必要，但是很多开发同学都比较抵触，所以推动起来也不是一件容易的事，建议先降低频率，小范围试点推行。代码检视的形式个人更倾向于由 tech leader 主讲的集体检视，相较于一对一检视的优势有以下几点： 检视过程是业务传递的过程，可以让大家都了解小组内彼此的业务 当发现问题时，纠正的过程就是一次集体的知识传递，能够让成员都了解这个规则 代码检视的最终目的就是提高大家的代码质量，和上图一样，从 Bad code 到 Good code 的过程其实就是代码检视时 WTF 数量逐渐收敛的过程，当大家的代码质量逐渐提高，代码检视时遇到的问题也会逐渐减少。 写在最后代码质量的提升必然是一个长期的过程，在这个过程中也许看不到即时收益，但是对于开发团队长期的发展而言是必不可少的，如果始终不去关注项目的代码质量，势必会导致技术债积压越来越多，到最后实在无法维护了，甚至需要重新立项进行整体的重构，到时就得不偿失了。","link":"/20210921/%E5%9B%A2%E9%98%9F%E4%B8%AD%E5%BA%94%E5%BD%93%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"},{"title":"vue 2.x 接入 typescript","text":"对于新项目，通过 vue-cli 手动选择需要的特性就可以很方便的接入 typescript，但对于一开始没有引入 typescript 的 vue 项目，再进行接入就较为繁琐了，最近公司就有一个项目是这种情况，折腾了比较久，在这里整理一下完整的引入方式。 基本框架为了更好的演示效果，使用 vue-cli 工具创建了一个默认的模板项目，即 preset 选择 default： 创建完成后项目技术栈为经典的 vue + js，项目目录结构如下： 该模板项目已经同步到 GitHub 上：vue2.x-ts-template，接下来开始进行 typescript 的引入。 安装依赖项目根目录下执行： 1npm install --save-dev typescript ts-loader@8.2.0 fork-ts-checker-webpack-plugin typescript: 无需太多解释，提供 ts 支持 ts-loader: 解析 ts 文件，⚠️注意：webpack 4.x 对应的 ts-loader 版本必须是 8.x fork-ts-checker-webpack-plugin: 更全面的 ts 语法检测，提供更完善的报错信息，以及对 .vue 单文件的支持 配置 webpack项目根目录下创建 vue.config.js 文件，配置代码如下： 12345678910111213141516171819202122232425262728293031323334353637const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin')module.exports = { configureWebpack: { // 入口文件根据项目实际情况填写，如不写，默认为 main.js entry: './src/main.ts', resolve: { extensions: ['.ts', '.tsx'] }, module: { rules: [ { // 解析 ts 与 tsx 文件 test: /\\.tsx?$/, loader: 'ts-loader', exclude: /node_modules/, options: { transpileOnly: true, appendTsSuffixTo: [/\\.vue$/], happyPackMode: false, }, }, ], }, plugins: [ // 用于提供完善的报错信息 new ForkTsCheckerWebpackPlugin({ async: false, typescript: { // 提供对 .vue 单文件的检测支持 extensions: { vue: true, }, }, }), ], },} 配置 tsconfig.json项目根目录下创建 tsconfig.json 文件，配置代码如下： 12345678910111213141516171819202122{ &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;.&quot;, &quot;experimentalDecorators&quot;: true, &quot;emitDecoratorMetadata&quot;: true, &quot;noEmitOnError&quot;: true, &quot;target&quot;: &quot;esnext&quot;, &quot;module&quot;: &quot;esnext&quot;, &quot;strict&quot;: true, &quot;allowJs&quot;: true, &quot;noEmit&quot;: false, &quot;noImplicitThis&quot;: true, &quot;esModuleInterop&quot;: true, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;paths&quot;: { &quot;@/*&quot;: [&quot;./src/*&quot;] } }, &quot;include&quot;: [&quot;**/*.vue&quot;, &quot;**/*.ts&quot;], &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;dist&quot;]} 至此，你已经可以进行 typescript 的编码了，语法有误时，编译报错如下： 接下来的步骤视项目具体情况而定。 添加自定义变量声明开发过程中通常会有自定义变量挂载到 vue 原型上的情况，以便于在其他地方直接使用 this. 进行调用，如 123456import Vue from 'vue'import * as api from &quot;@/service/api&quot;;// 将 $api 对象挂载到 vue 原型Vue.prototype.$api = api 但在其他的 ts 文件中进行引用时，会发现 $api 对象无法识别导致报错： 12this.$api.getAppName()// error: TS2339: Property '$api' does not exist on type 'CombinedVueInstance &gt;&gt;'. 这是因为 typescript 对类型有严格的检测机制，未声明的属性或变量被引用了就会报错，解决方法即手动添加一个类型定义文件，在 src 目录下创建 global.d.ts 文件，定义 vue 上的自定义变量： 1234567import Vue from 'vue'declare module 'vue/types/vue' { interface Vue { $api: any }} 添加 window 变量声明与上一步骤类似，对于 window 上的自定义变量，如果没有定义就引用，同样会导致报错，解决方法为在 src 目录下创建 window.d.ts 文件，定义 window 上的自定义变量： 123interface Window { customProperty: any} 然后就可以引用自定义属性了: window.customProperty 写在最后完成以上所有步骤后，demo 项目的目录结构如下： 关于 vue 中如何使用 typescript，可以参考官方文档基本用法，接下来就愉快的使用 ts 吧～","link":"/20220108/vue-2-x-%E6%8E%A5%E5%85%A5-typescript/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"兼容性","slug":"兼容性","link":"/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"CI&#x2F;CD","slug":"CI-CD","link":"/tags/CI-CD/"},{"name":"流水线","slug":"流水线","link":"/tags/%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"name":"代码质量","slug":"代码质量","link":"/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"}],"categories":[{"name":"个站","slug":"个站","link":"/categories/%E4%B8%AA%E7%AB%99/"},{"name":"Web 技术","slug":"Web-技术","link":"/categories/Web-%E6%8A%80%E6%9C%AF/"},{"name":"工程实践","slug":"工程实践","link":"/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"}]}