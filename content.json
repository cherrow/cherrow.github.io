{"pages":[{"title":"","text":"64fc6d6fc4408b48b38dc3f189de2a61","link":"/baidu_verify_code-c90Iop9840"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo d More info: Deployment","link":"/posts/4a17b156"},{"title":"vue 2.x 接入 typescript","text":"对于新项目，通过 vue-cli 手动选择需要的特性就可以很方便的接入 typescript，但对于一开始没有引入 typescript 的 vue 项目，再进行接入就较为繁琐了，最近公司就有一个项目是这种情况，折腾了比较久，在这里整理一下完整的引入方式。 基本框架为了更好的演示效果，使用 vue-cli 工具创建了一个默认的模板项目，即 preset 选择 default： 创建完成后项目技术栈为经典的 vue + js，项目目录结构如下： 该模板项目已经同步到 GitHub 上：vue2.x-ts-template，接下来开始进行 typescript 的引入。 安装依赖项目根目录下执行： 1npm install --save-dev typescript ts-loader@8.2.0 fork-ts-checker-webpack-plugin typescript: 无需太多解释，提供 ts 支持 ts-loader: 解析 ts 文件，⚠️注意：webpack 4.x 对应的 ts-loader 版本必须是 8.x fork-ts-checker-webpack-plugin: 更全面的 ts 语法检测，提供更完善的报错信息，以及对 .vue 单文件的支持 配置 webpack项目根目录下创建 vue.config.js 文件，配置代码如下： vue.config.js12345678910111213141516171819202122232425262728293031323334353637const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin')module.exports = { configureWebpack: { // 入口文件根据项目实际情况填写，如不写，默认为 main.js entry: './src/main.ts', resolve: { extensions: ['.ts', '.tsx'] }, module: { rules: [ { // 解析 ts 与 tsx 文件 test: /\\.tsx?$/, loader: 'ts-loader', exclude: /node_modules/, options: { transpileOnly: true, appendTsSuffixTo: [/\\.vue$/], happyPackMode: false, }, }, ], }, plugins: [ // 用于提供完善的报错信息 new ForkTsCheckerWebpackPlugin({ async: false, typescript: { // 提供对 .vue 单文件的检测支持 extensions: { vue: true, }, }, }), ], },} 配置 tsconfig.json项目根目录下创建 tsconfig.json 文件，配置代码如下： tsconfig.json12345678910111213141516171819202122{ &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;.&quot;, &quot;experimentalDecorators&quot;: true, &quot;emitDecoratorMetadata&quot;: true, &quot;noEmitOnError&quot;: true, &quot;target&quot;: &quot;esnext&quot;, &quot;module&quot;: &quot;esnext&quot;, &quot;strict&quot;: true, &quot;allowJs&quot;: true, &quot;noEmit&quot;: false, &quot;noImplicitThis&quot;: true, &quot;esModuleInterop&quot;: true, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;paths&quot;: { &quot;@/*&quot;: [&quot;./src/*&quot;] } }, &quot;include&quot;: [&quot;**/*.vue&quot;, &quot;**/*.ts&quot;], &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;dist&quot;]} 至此，你已经可以进行 typescript 的编码了，语法有误时，编译报错如下： 接下来的步骤视项目具体情况而定。 添加自定义变量声明开发过程中通常会有自定义变量挂载到 vue 原型上的情况，以便于在其他地方直接使用 this. 进行调用，如 main.ts123456import Vue from 'vue'import * as api from &quot;@/service/api&quot;;// 将 $api 对象挂载到 vue 原型Vue.prototype.$api = api 但在其他的 ts 文件中进行引用时，会发现 $api 对象无法识别导致报错： home.vue12this.$api.getAppName()// error: TS2339: Property '$api' does not exist on type 'CombinedVueInstance &gt;&gt;'. 这是因为 typescript 对类型有严格的检测机制，未声明的属性或变量被引用了就会报错，解决方法即手动添加一个类型定义文件，在 src 目录下创建 global.d.ts 文件，定义 vue 上的自定义变量： global.d.ts1234567import Vue from 'vue'declare module 'vue/types/vue' { interface Vue { $api: any }} 添加 window 变量声明与上一步骤类似，对于 window 上的自定义变量，如果没有定义就引用，同样会导致报错，解决方法为在 src 目录下创建 window.d.ts 文件，定义 window 上的自定义变量： window.d.ts123interface Window { customProperty: any} 然后就可以引用自定义属性了: window.customProperty 写在最后完成以上所有步骤后，demo 项目的目录结构如下： 关于 vue 中如何使用 typescript，可以参考官方文档基本用法，接下来就愉快的使用 ts 吧～","link":"/posts/5141e527"},{"title":"兼容性问题不完全记录","text":"前端开发的朋友肯定遇到过不少兼容性问题，包括不同浏览器、不同设备、同一浏览器不同版本等等，这篇文章就用来记录我在日常开发中遇到过的一些兼容性问题，吃一堑长一智，同样的问题下次再遇到就能混个脸熟了。 样式大部分情况其实都是样式兼容性问题，如果有不确定的样式，建议先去 caniuse 搜索一下，这个网站会详细列出你搜索样式的所有兼容情况。 flex 布局现象： 使用 align-items: end 实现子元素底部对齐，Chrome 浏览器生效，Safari 不生效。 排查： 在 caniuse 网站中搜索该样式，发现 align-items 属性不仅用于 flex 布局，还可用于 grid 布局，而属性值 start 和 end 在 flex 布局中是不兼容 Safari 浏览器的，必须使用 flex-start 和 flex-end。 解决： 改为 align-items: flex-end 即可。 js大家都知道 JavaScript 其实是由三部分组成： ECMAScript：由 ECMA-262 定义并提供核心功能； 文档对象模型(DOM)：提供与网页内容交互的方法和接口； 浏览器对象模型(BOM)：提供与浏览器交互的方法和接口。 ECMAScript 作为核心 API 本身是不存在兼容性问题的，只是它与 BOM 和 DOM 一样，不同浏览器对 API 的实现与支持有可能不同，因此就会导致兼容性问题的出现。 Date 格式化现象： 在对日期进行格式化时，发现 Chrome 和 Safari 的表现不一样： 1234var date = new Date('2021-10-25 12:50');console.log(date)// Chrome ---&gt; Mon Oct 25 2021 12:50:00 GMT+0800 (中国标准时间)// Safari ---&gt; Invalid Date 排查： 查阅 MDN 发现，在部分浏览器中所要解析的日期必须符合 ISO 8601 日期格式，显然 Safari 就是其中之一。在 Safari 中验证结果如下： 1234567console.log(new Date('2021-10-25')) // Mon Oct 25 2021 08:00:00 GMT+0800 (CST)console.log(new Date('2021/10/25')) // Mon Oct 25 2021 00:00:00 GMT+0800 (CST)console.log(new Date('2021-10-25T12:50')) // Mon Oct 25 2021 12:50:00 GMT+0800 (CST)console.log(new Date('2021-10-25T12:50Z')) // Mon Oct 25 2021 20:50:00 GMT+0800 (CST)console.log(new Date('2021/10/25T12:50')) // Invalid Dateconsole.log(new Date('2021/10/25T12:50Z')) // Invalid Dateconsole.log(new Date('2021/10/25 12:50')) // Mon Oct 25 2021 12:50:00 GMT+0800 (CST) 解决： 采用了替换横杠为斜杠的方式： 1234var date = new Date('2021-10-25 12:50'.replace(/-/g, '/'))console.log(date)// Chrome ---&gt; Mon Oct 25 2021 12:50:00 GMT+0800 (中国标准时间)// Safari ---&gt; Mon Oct 25 2021 12:50:00 GMT+0800 (CST)","link":"/posts/75245376"},{"title":"利用 GitLab CI&#x2F;CD 搭建质量检查流水线","text":"前面的文章有介绍团队如何去提高代码质量，其中比较重要的一个环节就是实现质量检查的流程化与自动化。这里的质量检查可以通过 ESLint 和 Sonar 的代码质量扫描实现，流程化自动化则采用 CI/CD 框架如 Jenkins、GitLab 来实现。 框架介绍GitLabGitLab 其实大家很熟悉，就是类似于 Github、码云之类的代码托管平台。这里想介绍的是 GitLab 的持续集成持续交付能力即 CI/CD，相较于 Jenkins， GitLab CI/CD 配置较为简单、与代码仓库结合紧密且可视化程度高。 SonarSonar 是一个静态代码扫描工具，它不仅可以像 ESLint 一样进行代码的质量检查，还可以从安全性、可维护性、测试覆盖率、代码复杂度、代码重复度等多个维度提供图表化的直观度量，每一次的扫描结果也会记录到服务端，以提供项目开发过程中的代码质量变化趋势。 搭建质量检查流水线流水线就是质量检查自动化的载体，它包含 ESLint 和 Sonar 两个步骤，每次提交代码将会自动触发流水线的运行，每次流水线运行也将触发 ESLint 和 Sonar 的执行。 GitLab CI/CD 的配置只需要在代码根目录下添加一个 yaml 文件 .gitlab-ci.yml，在这个配置文件中增加 ESLint 和 Sonar 的步骤即可，示例代码如下： 12345678910111213141516stages: - lint - sonar lint: stage: lint image: node:latest script: - npm install - npm run lint sonar: stage: sonar image: sonar-scanner:latest script: - sonar-scanner -Dsonar.projectKey=project-name -Dsonar.sources=./src -Dsonar.host.url=https://sonar.server.com -Dsonar.login=your-token 介绍一下其中部分参数： stages：即流水线的步骤，这里一共定义了两个步骤：lint 和 sonar，注意 stages 是串行的，默认情况下只有前一个步骤运行成功了，才能触发后面步骤的运行； image：即步骤执行脚本时所用到的镜像，在 lint 这一步骤中用到的镜像是 node 的最新版本，因为脚本中有 npm，所以必须拉取node 镜像才能执行，sonar 步骤中的镜像则拉取了 sonar-scanner 的最新版本； script：这个比较容易理解，即每个步骤运行时对应要执行的脚本。 其中 sonar 这一步骤的脚本定义了四个参数，意义如下： 参数 含义 是否必须 sonar.projectKey sonar 服务端中对应的 project key，需要先在 sonar 中新建对应的项目 是 sonar.sources sonar 扫描的代码目录，为相对根目录的路径 否 sonar.host.url sonar 服务端地址 是 sonar.login sonar 服务端生成的 token，鉴权使用 否 验证GitLab 流水线默认情况下 push 了代码就会触发运行，提交代码后进入 GitLab –&gt; CI/CD –&gt; Pipelines 查看是否运行成功，每个 stage 可以点击进去查看相关日志，sonar 运行完成后，进入 sonar 服务端查看对应的扫描结果。","link":"/posts/65491b3c"},{"title":"团队中应当如何提升代码质量","text":"代码质量其实是老生常谈的一个词，同时 质量 也是一个很主观的词，代码质量的好与坏究竟该如何评判，是否有一个定性和定量的标准，有了这个标准之后，在团队中间又将如何推动落地，希望这篇博文能够为你带来一点思路。 为什么要谈代码质量很大一部分开发同学有一个认知，觉得代码 “能跑就行了”，写完自己多看一眼就会看不懂的代码之后，大手一挥完全不顾后来人的死活。相信很多开发同学都碰到过这样的代码： 一个几百上千行的函数中间充斥着多年前留下来的古老注释与不明所以的分支逻辑，没有人敢删，也没有人敢改，所有业务知识全靠口口相传，新的需求如果要动到这段上古代码，就只能开始祈祷式编程，结果往往也是代码一动 bug 就来了。 如果你有共鸣，那我相信你内心其实是知道提高代码质量的必要性的，在我看来，提升代码质量的意义在于： 降低新人的学习成本 降低代码的后期维护成本 降低莫名其妙的 bug 出现率 增强编码人员对代码的信心 如何落地在团队中的落地实践是我想重点谈一谈的，落地的过程中少不了硬性规定的实施与相关技能的培训，所以前期需要投入一定精力去建设质量保障体系，具体如下： 制定规范与标准规范与标准的制定对于每个团队而言都大同小异，没有标准答案，关键是一定要在团队内部达成共识，在这里强烈建议参考《代码整洁之道》一书中的一到四章，熟读之后能够对规范的制定有一个更加具体的思路。这里我举几条之前公司的规范以供参考： 使用了 TypeScript 的项目，函数必须显式标明参数类型与返回值类型，void 除外 变量必须以驼峰形式英文命名，且不得有缩写的单词，行业或业务专有名词除外 变量命名需有明确的业务含义，不得以 info/data/list 这种毫无意义的单词进行命名 补充必要的单元测试这里提到的单元测试（unit test）是指由开发人员在代码中去编写的测试，前端单元测试框架推荐 Jest，单元测试可以让你在阅读以前的代码时，多一个途径去了解相关的业务逻辑，同时也能够增强改动这段代码的信心。如果你对单元测试没有概念，可以参考以下这个示例： 123456789101112131415161718192021// 以下是业务逻辑onComponentInit() { if (this.isCreate) { this.tip = 'create mode'; this.tipService.updateTip(this.tip); }}// 以下是对应的单元测试test('should get expected tip and call update tip method when component init giving isCreate is true', () =&gt; { // given component.isCreate = true; const methodSpy = jest.spyOn(TestBed.inject(TipService), 'updateTip'); // when component.onComponentInit(); // then expect(component.tip).toEqual('create mode'); expect(methodSpy).toHaveBeenCalledWith('create mode');}); 好的代码应当是自描述的，好的单元测试也是。以上这个单元测试做了两件事： 告诉阅读这段业务逻辑的人，这个分支下会做两件事情：给一个变量赋值、调用一个方法 保护这段业务逻辑不受重构的伤害，当你删除任何一行业务逻辑中的代码，这个单元测试就会运行失败 质量检查流程化自动化当开发同学写完代码之后，我们又该如何去判断代码质量的高低呢？首先还是建议引入一些自动化工具来做这件事情，质量检查应当是一个持续的、轻量的过程，不应当也不可能花费太多人力成本在这件事上。检查的流程建议至少包含这三个阶段： 单元测试覆盖率检查 lint 格式检查 sonar 静态代码扫描 对于有 CI （如 Jenkins）相关基础设施的团队，可以充分利用持续集成的优势，为项目配置一条包含以上三个步骤的流水线，保证每次 push 代码之后都能够触发代码质量的自动检查。如果没有 CI 相关设施，可以利用 Git Hooks 在 push 的时候在本地进行质量的检查。有了定性的检查措施之后，流水线运行失败就意味着代码质量没有达到约定的标准，进而督促相关的开发同学对自己的代码进行改进。 定期代码检视（code review）代码检视很有必要，但是很多开发同学都比较抵触，所以推动起来也不是一件容易的事，建议先降低频率，小范围试点推行。代码检视的形式个人更倾向于由 tech leader 主讲的集体检视，相较于一对一检视的优势有以下几点： 检视过程是业务传递的过程，可以让大家都了解小组内彼此的业务 当发现问题时，纠正的过程就是一次集体的知识传递，能够让成员都了解这个规则 代码检视的最终目的就是提高大家的代码质量，和上图一样，从 Bad code 到 Good code 的过程其实就是代码检视时 WTF 数量逐渐收敛的过程，当大家的代码质量逐渐提高，代码检视时遇到的问题也会逐渐减少。 写在最后代码质量的提升必然是一个长期的过程，在这个过程中也许看不到即时收益，但是对于开发团队长期的发展而言是必不可少的，如果始终不去关注项目的代码质量，势必会导致技术债积压越来越多，到最后实在无法维护了，甚至需要重新立项进行整体的重构，到时就得不偿失了。","link":"/posts/44b11549"},{"title":"CSS 绘制渐变圆角边框透明背景按钮","text":"最近有个比较酷炫的项目，其中有个需求是这样的：圆角矩形按钮，边框是渐变色，背景需透明。网上找了很多资料，在我快要放弃时还是找到了解决方案，不得不说 CSS 相当强大，只要你想不到，没有它做不到。尝试过的方法总结下来就以下三种，下面就回顾一下踩坑的过程。 border-image 实现渐变这是最开始尝试的方案，直接用 border-image 来实现边框的渐变效果，但是三个需求中只能实现边框渐变和背景透明，无法实现圆角。可以看下面的代码示例： 利用绝对定位进行背景遮盖由于 border-image 与 border-radius 无法同时生效，只能继续找方案。网上最多的方式就是这一种，原理其实很简单，首先利用绝对定位在按钮的下面放置一个 div（伪元素也可），然后将这个 div 的 background-image 设置成渐变色，最后再将按钮的背景色设置为一个纯色，且设置 background-clip: padding-box，这是为了避免上层的背景延伸至下层外边框导致渐变色被覆盖（具体可查看 MDN），这样底层与上层的间隔看起来就像是一个渐变色的边框。 但是很遗憾，这种方式也只能满足两个需求：边框渐变与圆角，无法实现背景透明。不过这种方式适用于页面背景是固定色的场景，因为页面背景如果是固定色，我们只需要将上层的背景色也设置为这个背景色就可以了，看起来就像是透明的一样。代码示例： 利用 mask 实现背景透明不得不说 stackoverflow 上的教程比国内大部分知识论坛网站都要好，下面这个方案就是在 stackoverflow 上找到的，原文提供了更多的解决方案，包括利用 svg 自己绘制背景，点击查看原文。原理其实和上一种方式差不多，不同之处就在于使用了 mask 相关的属性实现了背景的透明，至此终于满足了三个需求：边框渐变、圆角、背景透明。","link":"/posts/a86434d"},{"title":"设计模式在前端中的实际应用","text":"设计模式是编程范式的一种，而编程范式其实和编程语言没有太大关系，因此无论前端还是后端，设计模式总会在代码重构中被频繁提到。实际上在前端开发中，真正应用到设计模式的还是少数，原因之一是前端业务逻辑复杂度不够，确实用不到设计模式。技术应当是服务于业务的，我始终认为不能够为了秀技术而去硬上技术，下面就介绍一下设计模式是怎么实际应用到我们项目中去的。 业务背景这个项目是一个问卷系统，大家使用过问卷就会知道，每个问题都可以设置一些规则上的校验，比如 必填 最多选择 n 项 满足某个表达式 这些规则可以通过我们的后台管理系统配置好，然后在前端请求问卷信息时全部拿到。也就是说这些校验规则会在前端进行校验，如果校验未通过，对应的问题就会出现错误提示。 以上就是大致的项目和需求背景，拿到这个需求脑海中第一个方案大概率就是 针对所有的问题，循环校验每一个规则 很容易能想象到伪代码大概是代码片段v1.0 这样： 代码片段v1.01234567891011for (let i = 0; i &lt; questions.length; i++) { for (let j = 0; j &lt; questions[i].rules.length; j++) { if (questions[i].rules[j].type === 'require'){ // do require validate } else if (questions[i].rules[j].type === 'maxcount') { // do maxcount validate } else if (questions[i].rules[j].type === 'expression') { // do expression validate } }} 这种方式最暴力也最省事，但是对于业务未来的扩展与变更而言，就会有点力不从心了。 首先，每增加一个校验规则，我们就需要多写一个 else if，而增加校验规则这种业务变更是明显可预知的； 同时，如果某个校验规则的逻辑发生变化，那么就需要改动到其中的某一个 if 块。 随着业务发展，最终的结果必然是 if else 越来越多，嵌套层级越来越深，接手的人越来越看不懂，最后演变为屎山。 现状我们问卷系统采用的技术栈是 react + typescript，使用了面向对象编程的风格，上述校验场景的代码进行简化后，实现细节如代码片段v2.0 所示： 代码片段v2.012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 问卷类，一个问卷包含多个问题export class Survey { questions: Question[] constructor(survey) { // 实例化所有问题 this.questions = survey.questions.map((item) =&gt; new Question(item)) } validate(): boolean { return this.questions.every((item) =&gt; item.validate()) }}// 问题类，一个问题包含多条规则export class Question { rules: Rule[] constructor(question) { // 实例化所有规则 this.rules = question.rules.map((item) =&gt; new Rule(item)) } validate(): boolean { return this.rules.every((item) =&gt; item.validate()) }}// 规则类，一个规则有多种类型export class Rule { type: string constructor(rule) { this.type = rule.type } // 根据规则的类型进行校验 validate(): boolean { if(this.type === 'require') { // do require validate } else if (this.type === 'maxcount') { // do maxcount validate } else if (this.type === 'expression') { // do expression validate } else { return true } }} 上述代码很好理解，其实就是将代码片段v1.0的双层 for 循环进行了简单的抽象，在可读性上比代码片段v1.0要好，但是在扩展性上依然和双层 for 循环一样，只要有需求变更，必然会改动到 Rule 类的 validate 方法，这也显然违背了开闭原则，即应当 面向扩展开放，面向修改封闭。 重构重构之前首先要明确这个场景的特点，根据特点来选择重构的手段。根据上述业务场景的描述，特点如下： 规则有多条，且会逐渐增加 每条规则根据不同的类型来进行区分 每条规则下有不同的校验逻辑 看到这种结构相同但内部实现不同的模型，脑海中第一个浮现出来的应该就是类的继承。通过类的继承来实现这种业务上的多态性，可以有效的降低耦合，便于扩展。而各个子类（这里即规则）可以通过一个标识（这里即规则类型）来进行区分，那么工厂模式就是最好的选择，通过工厂来构造出每一个子类。重构后的代码如下代码片段v3.0： 代码片段v3.012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485export class Survey { questions: Question[] constructor(survey) { this.questions = survey.questions.map((item) =&gt; new Question(item)) } validate(): boolean { return this.questions.every((item) =&gt; item.validate()) }}export class Question { rules: Rule[] constructor(question) { // 这里实例化规则需要去调用工厂方法 this.rules = question.rules.map((item) =&gt; new RuleFactory.create(item)) } validate(): boolean { return this.rules.every((item) =&gt; item.validate()) }}// 规则基类，不做逻辑处理export class Rule { type: RuleType constructor(rule) { this.type = rule.type } validate(): boolean { return true }}// 规则子类，只做必填规则的校验export class RequireRule extends Rule { constructor(rule) { super(rule) } validate(): boolean { // do require validate }}// 规则子类，只做最大可选项的校验export class MaxCountRule extends Rule { constructor(rule) { super(rule) } validate(): boolean { // do maxcount validate }}// 规则子类，只做表达式的校验export class ExpressionRule extends Rule { constructor(rule) { super(rule) } validate(): boolean { // do expression validate }}// 规则工厂类，只做规则类的实例化export class RuleFactory { static create(rule) { if(rule.type === 'require') { return new RequireRule(rule) } else if (rule.type === 'maxcount') { return new MaxCountRule(rule) } else if (rule.type === 'expression') { return new ExpressionRule(rule) } else { return new Rule(rule) } }} 重构完成后可以看到，原来的 if else 逻辑被抽离成了三个不同的子类，每个子类的职责也是单一的，只负责对自己这一个校验规则进行校验，短小且职责单一的类是《代码整洁之道》中大力推崇的编程范式，这样也非常便于后续的扩展与维护。 至此，我们的重构就结束了，大家可以再从头捋一遍整个重构的思路，相信下次再碰到类似的场景，脑海中就能立马想到如何优化了。","link":"/posts/17149ec0"},{"title":"一次 WebView 的内存优化","text":"前段时间团队的一个 H5 项目 经历了机器发烫、交互卡顿甚至页面 crash 等故障，排查后发现是内存占用异常导致的。经过连续一周的熬夜优化，目前总算趋于稳定，在这里记录一下问题排查以及性能优化的过程。 项目介绍先介绍一下项目，技术框架是采用的 Vue 单页面应用，入口是在我们的 app 中，承载方式就是 app 中的 webview，这里主要介绍项目的两个页面： 首页。首页是一个图片列表，点击列表项就会跳转到详情页； 商品详情页。详情页中会包含商品详情图以及描述大图。 看起来其实很简单，怎么也不会想到这么简单的页面会引起内存溢出的问题。那么问题是怎么暴露出来的呢？ 问题定位直接原因是项目引入了 threejs 来渲染 3D 模型，我们发现在进入 3D 商品的详情页后，肉眼可见的会有页面卡顿甚至渲染阻塞，随后发现手机开始发烫，再多进几个 3D 商品的详情页后，必现 webview crash。 通过 adb 工具调试后发现，从首页进入 3D 详情页会使得内存占用增加 200M～800M 不等，3D 模型越大，占用的内存也越高，令人惊讶的是从详情页返回到首页之后，内存占用依然不会下降，导致每进入一次详情页都会使得内存进行累加，直到超出 webview 的内存限制后被 kill。 进一步的排查发现，不仅 3D 模型如此，普通的图片也会导致内存上升且无法被回收，只不过内存增加只有几十兆，也就意味着当图片详情累加的足够多时，依然会造成页面 crash。 发现这个问题后项目组马上开了紧急会议并制定了一系列方案： 把 3D 模型的展示方式更改为图片展示，以序列帧动画的方式替代原来的 3D 渲染，以降低内存增加率。 将线上首页和详情页的图片进行 CDN 加参压缩，包括尺寸压缩和 webp 压缩，保证所有图片大小不超过300k。 首页列表增加图片懒加载，只加载一屏中的图片。 与 app 端的同事确认内存回收机制，是否可提供手动释放内存的 sdk。 排查代码逻辑，是否引用不当导致页面销毁时未释放对象造成内存泄漏。 做完以上 1、2 、3点之后，已经不会再有 crash 的情况出现了，但是部分疑问还是没有解开。 一些疑问 为什么页面销毁之后内存未释放？ 这个问题我们也去咨询了 app 端的同事，他们给出的回复是客户端自主行为，也就是说内存的增加是 webview 自己的行为。经过反复调试，发现这部分内存其实是加载图片后增加的，可以理解为 webview 将这些加载完成的图片缓存进了内存（注意不是磁盘缓存，local storage 就属于磁盘缓存，可以被手动清空），下次再进入时就不用再去进行网络请求加载图片了。 为什么图片大小只有 1M，内存却会增加 50～80M？ 查阅文档后发现图片所占用的手机内存和图片体积呈正相关，但不是对等的。图片占用的内存大小和图片尺寸、图片像素、手机 dpi、渲染引擎等都有关系，所以几兆的图片却能占用几百兆的内存。 总结与思考 对于新框架或者新技术的引入一定要有足够的预研时间，需要充分评估风险，对于 WebGL 相关的技术应当保持谨慎，这次问题的暴露就是因为引入 threejs 时没有充分验证。 webview 中加载的图片大小不应超过 300k。应当对图片占用的内存持有敬畏之心，尤其注意 webview 中有通过内存缓存图片的机制。 图片长列表要做懒加载。懒加载能有效提升加载效率以及首屏内存占用率。","link":"/posts/3e5d451e"},{"title":"JavaScript简洁之道","text":"《Clean Code》这本书我在之前的博客中也有提到，不得不说它对我现在良好的编码风格有着极大的影响，该书虽然是以 Java 为模板来编写的，但其中大多数的思想与范式可以适用于任何语言。这篇博客中的原文（原文：clean-code-javascript，翻译版：JavaScript 风格指南）就是在借鉴了《Clean Code》之后为 JavaScript 设计编写的，我在原文中挑选了一些较为接地气、很快就能上手应用的规则出来，并在每一条中都添加了自己在实际项目中的理解，便于大家参考并落地实践。 变量使用有意义，可读性好的变量名反例: 1var yyyymmdstr = moment().format('YYYY/MM/DD'); 正例: 1var yearMonthDay = moment().format('YYYY/MM/DD'); 我的理解： 项目中看到太多毫无意义、可读性差的变量名了，现在我随便打开一个项目就能看到两个：list、upinfo，这种命名对于理解代码上下文、捋清业务逻辑没有任何好处，对于有意义的命名，名字取得再长也是值得的，如：showReceiveCardDialog、activeCardPack。 使用 ES6 的 const 定义常量反例中使用”var”定义的”常量”是可变的。 在声明一个常量时，该常量在整个程序中都应该是不可变的。 反例: 1var FIRST_US_PRESIDENT = &quot;George Washington&quot;; 正例: 1const FIRST_US_PRESIDENT = &quot;George Washington&quot;; 我的理解： 可变性这里不再赘述，想补充一点的是，我们应当尽量避免在代码中出现 Magic number（魔术数），对于魔术数，应当使用 const 来定义成一个名字有业务含义的常量，便于提高代码的可维护性与可读性。如： 12345678910// 不推荐这样写，这里的 525600 即魔术数，525600 是什么?for (var i = 0; i &lt; 525600; i++) { runCronJob();}// 以下为推荐写法const MINUTES_IN_A_YEAR = 525600;for (let i = 0; i &lt; MINUTES_IN_A_YEAR; i++) { runCronJob();} 使用说明变量(即有意义的变量名)反例: 12const cityStateRegex = /^(.+)[,\\\\s]+(.+?)\\s*(\\d{5})?$/;saveCityState(cityStateRegex.match(cityStateRegex)[1], cityStateRegex.match(cityStateRegex)[2]); 正例: 123456const ADDRESS = 'One Infinite Loop, Cupertino 95014';const cityStateRegex = /^(.+)[,\\\\s]+(.+?)\\s*(\\d{5})?$/;const match = ADDRESS.match(cityStateRegex)const city = match[1];const state = match[2];saveCityState(city, state); 我的理解： 这也是项目中特别常见的问题，在 if 的条件判断语句中尤其突出。经常能看到一个 if 判断里包含了一大堆逻辑判断，与、或、取反混合运算甚至一行都写不下，认真看半天还没能看懂这个条件是什么意思，如果我们把这个逻辑判断抽离出来，用 const 定义一个有含义的变量，那么代码的可读性将会大大提升，如： 12345678910// 不推荐if (file.open(fileName, &quot;w&quot;) !== null &amp;&amp; (...) || (...)) { ...}// 推荐写法const existed = (file.open(fileName, &quot;w&quot;) !== null) &amp;&amp; (...) || (...);if (existed) { ...} 函数函数参数 (理想情况下应不超过 2 个)限制函数参数数量很有必要，这么做使得在测试函数时更加轻松。过多的参数将导致难以采用有效的测试用例对函数的各个参数进行测试。 应避免三个以上参数的函数。通常情况下，参数超过两个意味着函数功能过于复杂，这时需要重新优化你的函数。当确实需要多个参数时，大多情况下可以考虑这些参数封装成一个对象。 JS 定义对象非常方便，当需要多个参数时，可以使用一个对象进行替代。 反例: 123function createMenu(title, body, buttonText, cancellable) { ...} 正例: 123456789const menuConfig = { title: 'Foo', body: 'Bar', buttonText: 'Baz', cancellable: true}function createMenu(menuConfig) { ...} 我的理解： 建议直接作为项目规范，超过 2 个参数需要定义为对象进行传参。 避免副作用当函数产生了除了“接受一个值并返回一个结果”之外的行为时，称该函数产生了副作用。比如在函数中更新dom、修改全局变量等就是产生了副作用。 反例: 1234567// 如果有其他函数也需要用到 name 变量，那么这时 name 已经不再是原来的样子了var name = 'Ryan McDermott';function splitIntoFirstAndLastName() { name = name.split(' ');}splitIntoFirstAndLastName();console.log(name); // ['Ryan', 'McDermott']; 正例: 12345678// 将 name 作为参数传进去，并返回一个新的变量，以保证不会对输入以及函数之外的变量有任何副作用function splitIntoFirstAndLastName(name) { return name.split(' ');}var name = 'Ryan McDermott'var newName = splitIntoFirstAndLastName(name);console.log(name); // 'Ryan McDermott';console.log(newName); // ['Ryan', 'McDermott']; 我的理解： 这里要说的就是尽量使用和编写纯函数，纯函数即不会产生副作用的函数，这样能最大程度避免莫名其妙的 bug 产生。 采用函数式编程函数式的编程具有更干净且便于测试的特点。尽可能的使用这种风格吧。 反例: 12345678910111213141516171819const programmerOutput = [ { name: 'Uncle Bobby', linesOfCode: 500 }, { name: 'Suzie Q', linesOfCode: 1500 }, { name: 'Jimmy Gosling', linesOfCode: 150 }, { name: 'Gracie Hopper', linesOfCode: 1000 }];const totalOutput = 0;for (let i = 0; i &lt; programmerOutput.length; i++) { totalOutput += programmerOutput[i].linesOfCode;} 正例: 123456789101112131415161718const programmerOutput = [ { name: 'Uncle Bobby', linesOfCode: 500 }, { name: 'Suzie Q', linesOfCode: 1500 }, { name: 'Jimmy Gosling', linesOfCode: 150 }, { name: 'Gracie Hopper', linesOfCode: 1000 }];const totalOutput = programmerOutput .map((programmer) =&gt; programmer.linesOfCode) .reduce((acc, linesOfCode) =&gt; acc + linesOfCode, 0); 我的理解： 不得不说，函数式编程特别方便与简洁，可项目中依然有使用上古方法一堆 for 循环做命令式编程的。对于数组，请务必尽情地使用 filter, map, reduce, find, sort 吧！ 封装判断条件反例: 123if (fsm.state === 'fetching' &amp;&amp; isEmpty(listNode)) { /// ...} 正例: 123456function shouldShowSpinner(fsm, listNode) { return fsm.state === 'fetching' &amp;&amp; isEmpty(listNode);}if (shouldShowSpinner(fsmInstance, listNodeInstance)) { // ...} 我的理解： 这一点和变量一节中提到的其实是一个事情，至于抽成变量还是抽成方法，就看需不需要传参了。 注释只对存在一定业务逻辑复杂性的代码进行注释注释并不是必须的，好的代码能够让人一目了然，不用过多无谓的注释。 反例: 123456789101112131415function hashIt(data) { // The hash var hash = 0; // Length of string var length = data.length; // Loop through every character in data for (var i = 0; i &lt; length; i++) { // Get character code. var char = data.charCodeAt(i); // Make the hash hash = ((hash &lt;&lt; 5) - hash) + char; // Convert to 32-bit integer hash = hash &amp; hash; }} 正例: 12345678910function hashIt(data) { var hash = 0; var length = data.length; for (var i = 0; i &lt; length; i++) { var char = data.charCodeAt(i); hash = ((hash &lt;&lt; 5) - hash) + char; // Convert to 32-bit integer hash = hash &amp; hash; }} 我的理解： 大家可以去看看自己的项目，代码里面充斥着多少毫无意义、丑陋不堪的注释，很多开发同学喜欢每个函数甚至每个变量都写上注释，建议把这些注释全删掉，重新给你的变量和函数取一个通俗易懂的名字吧，如： 1234567891011// 用户信息const info = {}// 获取用户信息function getInfo() {}// 下面这样是不是清爽多了？const user = {}function getUser() {} 不要在代码库中遗留被注释掉的代码版本控制的存在是有原因的。让旧代码存在于你的 history 里吧。 反例: 1234doStuff();// doOtherStuff();// doSomeMoreStuff();// doSoMuchStuff(); 正例: 1doStuff(); 我的理解： 这也是个大问题，所有被注释的代码似乎都有着同一个使命：“以后说不定用得上呢”。我一贯坚持当前不用的代码就直接删掉，坚决不提交到 git 上去，现在 git 这么方便，还怕要用的代码找不回来吗？注释的代码只会让你的项目越来越臃肿越来越难看，看到这里，快去把你项目中的注释删掉吧。","link":"/posts/5772e7ea"},{"title":"H5 性能优化","text":"之前有篇文章粗略聊了一下 webview 的内存优化问题，只涉及到了图片的优化，这篇文章准备较为全面地介绍一下 H5 项目可以采用的方便落地的一些性能优化方式。 加载时优化加载时的优化主要是为了减少用户从入口到看到内容展示这中间的白屏时间，这部分时间浏览器的主要工作就是 DNS 解析、建立 HTTP 连接、加载 JS、解析 dom，针对这几个步骤，我们在项目中处理的方式有： DNS 解析优化在index.html中添加link标签用于预解析： dns-prefetch 这个标签我们在项目中用于解析静态资源的域名，建议用于图片服务器的域名解析或 CDN 域名解析。 preconnect 这个标签则适用于对后端接口域名进行解析，该标签除了解析 DNS 外，还会预先进行 TCP 连接。 12&lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://www.a.static.com&quot; /&gt;&lt;link rel=&quot;preconnect&quot; href=&quot;https://www.b.api.com&quot; /&gt; HTTP 请求优化 减少 HTTP 请求数量 接口合并，合成雪碧图，文件合并，复用图片地址，本地缓存数据。 减少 HTTP 请求大小 webpack 进行拆包压缩，对静态资源（包括 JS、CSS、图片、字体等）进行大小压缩与限制，推荐的 webpack 插件：UglifyPlugin、SplitChunksPlugin、CommonsChunkPlugin。 使用 HTTP2 相对 HTTP1，有解析速度快、多路复用、首部压缩等特性，这个我们项目中没有实践，有兴趣的朋友可以去研究一下。 服务端渲染项目一开始没有考虑 SSR 的话，后期进行改造实现成本会稍高，但如果同时有 SEO 需求，可以考虑服务端渲染，客户端加载速度会有很大提升。 运行时优化页面渲染优化 避免table布局,使用flex布局 一个很小的改动都可能造成整个table重新布局，现在flex布局已经相当普遍了，能上flex就上。 使用 transform 来改变位置 直接更改元素的 top, left 等值会引起重排重绘，建议使用 tranform: translate 来 更新位置。这点在编写动画时对页面渲染有肉眼可见的影响，频繁改动top等值很容易让页面卡顿。 内存优化 页面缓存 keep-alive 避免每次回到上级页面都要重新渲染，vue框架可以直接使用。 长列表优化 无限滚动的大数据建议考虑虚拟列表的方案，否则当数据加载超过临界值，很有容易出现 H5 页面 crash 的情况。首屏也可以使用懒加载的方式去渲染列表，只渲染一屏内的数据，减少内存开销。 考虑多页面方案 当单页面应用体积过大已经无法继续优化时，可以改变一下思路，将单页面应用改成多页面应用，如果是通过 webview 进行加载的话，多页面应用就可以对应的用多个 webview 容器来承载，这样就将内存分散到了各个 webview 容器中。 性能检测与分析没有性能检测工具的话很难将优化效果量化出来，这里介绍一下我们在项目中常用到的： Chrome Performance这个工具算是最亲民最好用的了，打开 F12 就可以很直观看到整个页面加载过程中的耗时，然后再进行针对性的优化，效果也可以通过 LCP、FCP 的时间来进行对比。 资源打包分析这里用的就是 webpack 的插件：webpack-bundle-analyzer，相信大部分前端er都用过，这个插件可以将我们整个项目打包后的资源大小占用直观的展现出来，再根据结果去针对性的做拆包等操作。 Sentry这是一个第三方的性能监控工具，我们组的项目基本都接入了这个工具，在管理后台可以看到用户的真实加载时间以及 JS 运行时报错。 写在后面以上的方法我个人认为都是能够落地去真正实施的，我们有个资源密集型项目按照上面的方式优化之后加载时长以及运行流畅度都有明显提升。以上方法写的可能有些粗，以后有时间会再对其中一些值得深入的优化方式单独讲讲。","link":"/posts/c9fa5e13"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"兼容性","slug":"兼容性","link":"/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"CI&#x2F;CD","slug":"CI-CD","link":"/tags/CI-CD/"},{"name":"流水线","slug":"流水线","link":"/tags/%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"name":"代码质量","slug":"代码质量","link":"/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"代码规范","slug":"代码规范","link":"/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}],"categories":[{"name":"个站","slug":"个站","link":"/categories/%E4%B8%AA%E7%AB%99/"},{"name":"Web 技术","slug":"Web-技术","link":"/categories/Web-%E6%8A%80%E6%9C%AF/"},{"name":"工程实践","slug":"工程实践","link":"/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"}]}